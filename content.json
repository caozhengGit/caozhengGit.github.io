{"meta":{"title":"愤怒的泡面","subtitle":null,"description":"工作是为了更好的生活","author":"CaoZheng","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2017-07-07T08:00:15.000Z","updated":"2017-07-07T08:00:54.741Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android开发中定制自己的线程池","slug":"Android开发中定制自己的线程池","date":"2017-10-27T09:05:04.000Z","updated":"2017-10-27T09:33:08.479Z","comments":true,"path":"2017/10/27/Android开发中定制自己的线程池/","link":"","permalink":"http://yoursite.com/2017/10/27/Android开发中定制自己的线程池/","excerpt":"","text":"ThreadPoolExecutor的构造方法ThreadPoolExecutor的构造方法有四个，如下: 12345678910111213141516171819202122232425262728293031323334353637public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造方法参数说明 corePoolSize 线程池的核心线程数，即线程池中的最小线程数 maximumPoolSize 最大线程池大小,当活动线程数达到这个值，后续任务会被阻塞 keepAliveTime 线程池中超过corePoolSize数目的非核心线程最大存活时间 unit keepAliveTime 参数的时间单位 workQueue 执行前用于保持任务的队列，也就是线程池的缓存队列 threadFactory 线程工厂，为线程池提供创建新线程的功能 RejectedExecutionHandler 线程池对拒绝任务的处理策略 定制自己的线程池1234567891011121314151617181920212223242526272829303132333435363738public class ThreadPoolFactory &#123; /** 核心线程数 */ private static final int CORE_POOL_SIZE = 5; /** 最大线程数 */ private static final int MAX_POOL_SIZE = 128; /** 非核心线程时超过时长 */ private static final int KEEP_ALIVE_TIME = 2; /** 阻塞队列大小 */ private static final int BLOCK_SIZE = 2; private ThreadPoolExecutor mThreadPoolExecutor ; private ThreadPoolFactory()&#123; createThreadPoolProxyFactory(); &#125; /** 创建线程池 */ private void createThreadPoolProxyFactory()&#123; mThreadPoolExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(BLOCK_SIZE), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //true: 线程池数量最后销毁到0个 //false: 超过核心线程数时,而且(超过最大值或者timeout过),就会销毁 mThreadPoolExecutor .allowCoreThreadTimeOut(true); &#125; /** * 打印线程池状态 */ public void logThreadPoolInfo() &#123; Log.i(\"threadPoolFactory\", \"monitor \" + \" CorePoolSize:\" + mThreadPoolExecutor.getCorePoolSize() + \" PoolSize:\" + mThreadPoolExecutor.getPoolSize() + \" MaximumPoolSize:\" + mThreadPoolExecutor.getMaximumPoolSize() + \" ActiveCount:\" + mThreadPoolExecutor.getActiveCount() + \" TaskCount:\" + mThreadPoolExecutor.getTaskCount()); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"Java线程池的使用","slug":"Java线程池的使用","date":"2017-10-27T03:30:18.000Z","updated":"2017-10-27T04:02:04.533Z","comments":true,"path":"2017/10/27/Java线程池的使用/","link":"","permalink":"http://yoursite.com/2017/10/27/Java线程池的使用/","excerpt":"","text":"new Thread与线程池new Thread的弊端 每次new Thread新建对象性能差。 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 缺乏更多功能，如定时执行、定期执行、线程中断。 相比new Thread，Java提供的四种线程池的好处在于： 重用存在的线程，减少对象创建、消亡的开销，性能佳。 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 四种线程池newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 12ExecutorService cacheThreadPool = Executors.newCachedThreadPool(); cacheThreadPool.execute(runnable); newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4); fixedThreadPool.execute(runnable); newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 12ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4); scheduledThreadPool.schedule(runnable3, 2000, TimeUnit.MILLISECONDS); newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 12ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();singleThreadExecutor.execute(runnable);","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"}]},{"title":"【Android异常】关于Android方法数量限制的问题","slug":"【Android异常】关于Android方法数量限制的问题","date":"2017-10-11T03:44:58.000Z","updated":"2017-10-11T06:25:56.619Z","comments":true,"path":"2017/10/11/【Android异常】关于Android方法数量限制的问题/","link":"","permalink":"http://yoursite.com/2017/10/11/【Android异常】关于Android方法数量限制的问题/","excerpt":"","text":"异常错误信息错误信息： 12345Error:Errorconverting bytecode to dex:Cause:com.android.dex.DexIndexOverflowException:field ID not in [0, 0xffff]: 65536:XXXXXX:transformClassesWithDexForDebug FAILEDError:Executionfailed for task ':XXXXXX:transformClassesWithDexForDebug'.&gt;com.android.build.api.transform.TransformException:com.android.ide.common.process.ProcessException:java.util.concurrent.ExecutionException:com.android.ide.common.process.ProcessException:org.gradle.process.internal.ExecException: Process 'command 'C:\\ProgramFiles\\Java\\jdk1.8.0_73\\bin\\java.exe'' finished withnon-zero exit value 2 限制Android方法数量的原因Android应用以DEX文件的形式存储字节码文件，在Dalvik字节码规范里，方法引用索引method referenceindex只有16位,即65536个。注意是method reference，这里限制的是自己代码、Android框架、第三方库三者方法数量的总和。 解决方法Google官方出的分包方案，采用MultiDex支持库 1，配置building.gradle，开启MultiDex 123456789android &#123; defaultConfig &#123; multiDexEnabled true &#125;&#125;dependencies&#123; compile'com.android.support:multidex:1.0.0'&#125;&#125; 2，配置应用 方法1：在AndroidManifest.xml的application中声明android.support.multidex.MultiDexApplication； 123456789&lt;?xmlversion=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifestxmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.android.multidex.myapplication\"&gt; &lt;application ... android:name=\"android.support.multidex.MultiDexApplication\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 方法2：让你自己的Application类继承MultiDexApplication 方法3：让你自己的Application类重写attachBaseContext 方法，12345@Overrideprotected void attachBaseContext(Context base) &#123;super.attachBaseContext(base);MultiDex.install(this);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"【旅行计划】西藏自驾游","slug":"【旅行计划】西藏自驾游","date":"2017-10-01T06:54:41.000Z","updated":"2017-10-02T08:48:35.470Z","comments":true,"path":"2017/10/01/【旅行计划】西藏自驾游/","link":"","permalink":"http://yoursite.com/2017/10/01/【旅行计划】西藏自驾游/","excerpt":"","text":"大致路线川藏线 + 青藏线 详细计划Day 1路线：重庆－泸定（1337）－新都桥（3469）－雅江（2600） 里程：760km，路况好 Day 2路线：雅江－理塘（3950）－芒康（3883）里程：400km，路况一般，弯多灰大 Day 3路线：芒康—左贡（3807）—八宿（3268） 里程：360km，路况一般，有涉水路段 景点：怒江七十二拐、川藏318经典垭口 Day 4路线：八宿—然乌湖（3900）—米堆冰川（3820）—波密（2724） 里程：220km，路况一般，有涉水路段，有落石路段 行程亮点：然乌湖、米堆冰川、波密景观大道 Day 5路线：波密—鲁朗（3383）—林芝 里程：230km，路况一般 行程亮点：通麦天险、鲁朗林海、南迦巴瓦峰 Day 6路线：林芝（3150）—工布江达（3419）—墨竹工卡（3820）—拉萨（3658） 里程：400km，路况好 行程亮点：拉林高速、尼洋河风光、米拉山 Day 7路线：拉萨—羊卓雍措（4440）—拉萨 里程：200km，路况好 行程亮点：羊卓雍措、雅鲁藏布江风光 Day 8路线：拉萨—当雄（4300）—纳木措（4718） 里程：220km，路况好 行程亮点：纳木措、星空 Day 9路线：纳木措—那曲（4500）－安多（4700） 里程：360km，路况好 行程亮点：纳木措日出、青藏铁路 Day 10路线：安多—唐古拉山（4900）－可可西里（4000）－格尔木（2900） 里程：700km（12小时），路况好 行程亮点：唐古拉山垭口、沱沱河、可可西里 Day 11路线：格尔木－茶卡盐湖（3100）－青海湖（3000） 里程：620km（7小时），路况好 行程亮点：茶卡盐湖、青海湖 Day 12路线：青海湖－天水 - 重庆 里程：1500km，路况好 费用油费：4000元 停车费：500元 食宿（2人）：吃150元/日，住200元/日，总计350元 景区门票：海螺沟景区：门票80元/人，观光车票60元/人（双程），观光索道150元/人（双程）； 亚丁风景区：门票150元/人，观光车120元/人，电瓶观光车80元，景区马费80—300元/人； 米堆冰川：50元/人；来古冰川：30/人；雅鲁藏布江大峡谷290元/人 布达拉宫：旺季200元/人，淡季100元/人；大昭寺：85元/人 哲蚌寺：55元/人；色拉寺：55元/人 小昭寺：20元/人；药王山：20元/人 甘丹寺：45元/人；纳木错：淡季100元/人，旺季120元/人 楚布寺：45元/人；直贡梯寺：45元/人 车辆保养和维修：大约在1000—3000元左右 注意事项 在藏区加油一定需要出示三个证件：身份证、驾驶证、行驶证 住酒店需要登记2人的身份证 过检查站时，除了司机是在车上检查，因为司机需要将车辆开过去，其余每个人都要下车到检查站里刷身份证才能通行，而且车上的行李都需要在旁边过安检，所以不要带违禁物品 除了正式的检查站之外，路上也有一些临时检查点，他们一般会在车上抽查一到二个人，然后检查身份证 高原地区的气候特点是早晚温差比较大 随车装备可准备充分一些，吃的喝的，自带了电热水壶和矿泉水 高原地区非常干燥，因此要多带一些保湿性比较好的护肤品，补水面膜也可以带着 高反药品：氧气包肯定必备，一旦高反吸氧是最好的治疗方法，其他高反药品 随车的工具箱、备胎、充气泵、搭电装备、拉车绳都需要带上","categories":[{"name":"旅行计划","slug":"旅行计划","permalink":"http://yoursite.com/categories/旅行计划/"}],"tags":[]},{"title":"【Android开源框架】之数据库框架","slug":"【Android开源框架】之数据库框架","date":"2017-09-27T04:40:27.000Z","updated":"2017-09-27T05:42:07.254Z","comments":true,"path":"2017/09/27/【Android开源框架】之数据库框架/","link":"","permalink":"http://yoursite.com/2017/09/27/【Android开源框架】之数据库框架/","excerpt":"","text":"GreenDAOGreenDAO是一个轻量级，快速的orm框架。简化建表、查询、更新、插入、事务、索引的操作特性: 性能突出(比ormlite快4-5倍), performance 库小，核心包小于100k 简单易用的API 支持protobuf 自动生成数据库访问代码 Realm移动端的数据库，适用于 Phone、Tablet、Wearable，支持 ORM，线程安全、支持连表及数据库加密，比 SQLite 性能更好。特性: 着重移动端 简单易用的API 支持线程安全，关系数据库和加密 访问快速 跨平台 OrmLiteOrmLite不是Android平台专用的orm框架，它是一个Java orm，OrmLite For Android增加了对Android平台的支持。 ActiveAndroidActiveAndroid是一个轻量级的orm框架，名称命令方式类似于Yii、Rails等使用的orm框架ActiveRecord DBFlow一个速度极快，功能强大，而且非常简单的 Android 数据库 ORM 库 Sugar用超级简单的方法处理Android数据库特性: 配置少 自动生成表结构 支持在不同模式版本直接切换","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"Hexo常用命令笔记","slug":"Hexo常用命令笔记","date":"2017-07-31T02:44:40.000Z","updated":"2017-07-31T02:57:53.456Z","comments":true,"path":"2017/07/31/Hexo常用命令笔记/","link":"","permalink":"http://yoursite.com/2017/07/31/Hexo常用命令笔记/","excerpt":"","text":"hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] 模版 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery” hexo new “Hello World” –lang tw 变量 描述layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[]},{"title":"Git 配置用户名、密码","slug":"Git-配置用户名、密码","date":"2017-07-31T02:40:10.000Z","updated":"2017-07-31T02:43:05.429Z","comments":true,"path":"2017/07/31/Git-配置用户名、密码/","link":"","permalink":"http://yoursite.com/2017/07/31/Git-配置用户名、密码/","excerpt":"","text":"在终端输入： 1$ git config --global credential.helper store 然后git pull一次，输入一次用户名密码就会自动保存该用户名密码； 查看配置的用户信息： 1$ git config --list","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[]},{"title":"Markdown 基本语法","slug":"Markdown-基本语法","date":"2017-07-12T02:51:11.000Z","updated":"2017-07-12T03:02:51.768Z","comments":true,"path":"2017/07/12/Markdown-基本语法/","link":"","permalink":"http://yoursite.com/2017/07/12/Markdown-基本语法/","excerpt":"","text":"关于MarkdownMarkdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 简单标记符完成排版，所写即所见，让你专注于文字而不是排版 纯文本，所以兼容性极强，可以用所有文本编辑器打开 格式转换方便，Markdown文本可以轻松转换为 html、pdf等 Markdown 的标记语法有极好的可读性 基础语法基础语法 高级语法高级语法","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[]},{"title":" 开源弹幕引擎·烈焰弹幕使(DanmakuFlameMaster)","slug":"开源弹幕引擎·烈焰弹幕使-DanmakuFlameMaster","date":"2017-07-11T05:35:13.000Z","updated":"2017-09-27T05:39:12.166Z","comments":true,"path":"2017/07/11/开源弹幕引擎·烈焰弹幕使-DanmakuFlameMaster/","link":"","permalink":"http://yoursite.com/2017/07/11/开源弹幕引擎·烈焰弹幕使-DanmakuFlameMaster/","excerpt":"","text":"简介DanmakuFlameMaster 是 Android 上开源弹幕解析绘制引擎项目，也是 Android 上最好的开源弹幕引擎·烈焰弹幕。其架构清晰，简单易用，支持多种高效绘制 B站xml弹幕格式解析 基础弹幕精确还原绘制 支持mode7特殊弹幕 多核机型优化，高效的预缓存机制 支持多种显示效果选项实时切换 实时弹幕显示支持 换行弹幕支持/运动弹幕支持 支持自定义字体 支持多种弹幕参数设置 支持多种方式的弹幕屏蔽 项目地址github地址：https://github.com/Bilibili/DanmakuFlameMaster Android Studio集成方法build.gradle中添加 123dependencies &#123; compile 'com.github.ctiao:dfm:0.4.2'&#125; 使用方法1.布局文件 1234&lt;master.flame.danmaku.ui.widget.DanmakuView android:id=\"@+id/sv_danmaku\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 2.初始化 private BaseDanmakuParser mParser;//解析器对象 private IDanmakuView mDanmakuView; private DanmakuContext mContext; mDanmakuView = (IDanmakuView) findViewById(R.id.sv_danmaku); mContext = DanmakuContext.create(); // 设置弹幕的最大显示行数 HashMap&lt;Integer, Integer&gt; maxLinesPair = new HashMap&lt;Integer, Integer&gt;(); // 滚动弹幕最大显示3行 maxLinesPair.put(BaseDanmaku.TYPE_SCROLL_RL, 3); // 设置是否禁止重叠 HashMap&lt;Integer, Boolean&gt; overlappingEnablePair = new HashMap&lt;Integer, Boolean&gt;(); overlappingEnablePair.put(BaseDanmaku.TYPE_SCROLL_LR, true); overlappingEnablePair.put(BaseDanmaku.TYPE_FIX_BOTTOM, true); mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, 3) .setDuplicateMergingEnabled(false) .setScrollSpeedFactor(1.2f) //是否启用合并重复弹幕 .setScaleTextSize(1.2f) //设置弹幕滚动速度系数,只对滚动弹幕有效 .setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter) // 图文混排使用SpannedCacheStuffer 设置缓存绘制填充器，默认使用{@link SimpleTextCacheStuffer}只支持纯文字显示, 如果需要图文混排请设置{@link SpannedCacheStuffer}如果需要定制其他样式请扩展{@link SimpleTextCacheStuffer}|{@link SpannedCacheStuffer} .setMaximumLines(maxLinesPair) //设置最大显示行数 .preventOverlapping(overlappingEnablePair); //设置防弹幕重叠，null为允许重叠 if (mDanmakuView != null) { mParser = createParser(this.getResources().openRawResource(R.raw.comments)); //创建解析器对象，从raw资源目录下解析comments.xml文本 mDanmakuView.setCallback(new master.flame.danmaku.controller.DrawHandler.Callback() { @Override public void updateTimer(DanmakuTimer timer) { } @Override public void drawingFinished() { } @Override public void danmakuShown(BaseDanmaku danmaku) { } @Override public void prepared() { mDanmakuView.start(); } }); mDanmakuView.prepare(mParser, mContext); mDanmakuView.showFPS(false); //是否显示FPS mDanmakuView.enableDanmakuDrawingCache(true); 3.创建解析器对象 /** * 创建解析器对象，解析输入流 * @param stream * @return */ private BaseDanmakuParser createParser(InputStream stream) { if (stream == null) { return new BaseDanmakuParser() { @Override protected Danmakus parse() { return new Danmakus(); } }; } ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI); try { loader.load(stream); } catch (IllegalDataException e) { e.printStackTrace(); } BaseDanmakuParser parser = new BiliDanmukuParser(); IDataSource&lt;?&gt; dataSource = loader.getDataSource(); parser.load(dataSource); return parser; } 注： DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI) //xml解析 DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN) //json文件格式解析 4.自定义弹幕背景和边距 private static class BackgroundCacheStuffer extends SpannedCacheStuffer { // 通过扩展SimpleTextCacheStuffer或SpannedCacheStuffer个性化你的弹幕样式 final Paint paint = new Paint(); @Override public void measure(BaseDanmaku danmaku, TextPaint paint) { danmaku.padding = 10; // 在背景绘制模式下增加padding super.measure(danmaku, paint); } @Override public void drawBackground(BaseDanmaku danmaku, Canvas canvas, float left, float top) { paint.setColor(0x8125309b); //弹幕背景颜色 canvas.drawRect(left + 2, top + 2, left + danmaku.paintWidth - 2, top + danmaku.paintHeight - 2, paint); } @Override public void drawStroke(BaseDanmaku danmaku, String lineText, Canvas canvas, float left, float top, Paint paint) { // 禁用描边绘制 } }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"毕业后这一年的收获","slug":"毕业后这一年的收获","date":"2017-07-07T07:00:11.000Z","updated":"2017-10-01T11:23:52.287Z","comments":true,"path":"2017/07/07/毕业后这一年的收获/","link":"","permalink":"http://yoursite.com/2017/07/07/毕业后这一年的收获/","excerpt":"","text":"去年的七月拿到毕业证正式毕业，一转眼就又是七月了，这一年还是经历了不少事，回头看看，这一年中的大多数选择还是比较满意的。今天趁着懒癌没发作，总结一下这一年的收获吧。 当前状况毕业一年，上海，创业公司，安卓开发，无房无车，几乎无存款，身体还算健康，但缺乏锻炼免疫力差，离家很远。 工作方面毕业后与毕业前最大的改变就是进入社会，开始工作。 庆幸今年没有因为工作中的一点不顺心就离职，毕竟工作还不满一年，那会儿换工作的话还需要花时间适应新工作新环境，能够用来学习提升的时间就更少了。 人们常说第一份工作会影响人的很多方面，包括人生观、价值观，的确如此，在过去一年工作中，我所在的公司在不停地变化，处在这个环境中的我，受益很多。 目标业务代码沟通协作未来目标在开始工作之前，我并没有思考过我为什么工作，因此在过去一年里我浪费了很多时间纠结迷茫徘徊，如果连目标都没设定，怎么能走得直走得快呢？ 工作的目的有很多，除了钱是一部分原因，有的人是不知道该干什么就先工作着吧，有的人是为了学技能攒经验去做更好的事，有的人是为了做些事业实现梦想，也有的人只是无聊找点事做。 我的中期目标是多年后回老家自己开家信息技术公司，具体业务还不清楚，但是前几年需要比较广地掌握三端（APP、WEB、后台）技能。 因此头两年的小目标就是先夯实安卓开发。 不足总结","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[]},{"title":"Hexo安装","slug":"Hexo安装","date":"2017-07-07T02:25:12.000Z","updated":"2017-07-07T08:17:31.528Z","comments":true,"path":"2017/07/07/Hexo安装/","link":"","permalink":"http://yoursite.com/2017/07/07/Hexo安装/","excerpt":"","text":"安装Git我们很经常会要用到Git以及Github，首先来安装Git： 下载Git 选择合适的版本下载然后安装，我们稍后将会用上。 安装Node.js因为Hexo是一款基于Node.js的静态博客框架，所以我们还需要安装好它： 下载Node.js 同样选择对应自己电脑的版本下载安装。 安装Hexo安装好Git和Node.js之后，轮到我们今天的主角登场了~先打开Git Bash，然后输入下面这条命令来安装Hexo： 1$ npm install hexo-cli -g 来试试安装成功没有，输入以下命令查看Hexo的版本信息： 1$ hexo -v 如果出现类似内容说明安装成功啦！ hexo-cli: 0.1.9 os: Windows_NT 6.1.7601 win32 ia32 http_parser: 2.3 node: 0.12.2 v8: 3.28.73 uv: 1.4.2-node1 zlib: 1.2.8 modules: 14 openssl: 1.0.1m Hexo的使用现在我们可以开始创建博客写文章了！是不是很快~下面会介绍几个Hexo的常用命令，掌握之后就能愉悦地开始写作之旅了XD 新建博客假设我在E盘有个叫blog的文件夹，现在我们用Git Bash进去这个文件夹里，然后将它初始化为我们的博客目录： 1$ hexo init 安装成功的提示信息： INFO Copying data to E:\\blog INFO You are almost done! Don&apos;t forget to run &apos;npm install&apos; before you start blogging with Hexo! 注意看到第二条！提示我们在开始使用前要先执行 1$ npm install 这条命令是用来安装依赖包的，具体安装内容可以在package.json文件里找到。安装好了之后会看到一大串的信息，这里就不贴出来了。现在我们可以看到blog目录下的文件结构是这样的： . ├── _config.yml ├── node_modules ├── package.json ├── scaffolds ├── source | └── _posts └── themes 新建文章1$ hexo new \"我的第一篇文章\" 生成界面1$ hexo generate 或者 hexo g 界面预览1$ hexo server 或者 hexo s 我们会看到这样一条提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 打开浏览器访问http://localhost:4000/ 配置信息是不是很激动！成功了有木有~不过等等，博客名写着Hexo，可不是我想的那样噢，还有还有，页面底部的版权信息里作者名字也不是我啊喂！来，我们来改掉它们！ 找到博客根目录下的配置文件_config.yml，用自己喜欢的文本编辑器编辑它。看到# Site的那一部分，里面的title就是博客的名字，subtitle就是副标题，author对应的那个就是作者名字啦，把自己的大名写上去吧！ 还有很多配置项可以修改，这里就不详细讲了，可以查看Hexo官方文档对照着修改配置。 更换主题在这个看脸的世界，我们的博客怎么可以没有颜值呢，折腾完上面的那些之后，是时候给博客挑上件漂亮的“衣服”了。 Hexo官方网站上展示了多套主题，可以按自己的口味挑选，或者动手能力强的，可以试着自己写一套独一无二的主题噢XD 这里以Apollo这个主题为例，进去github页面之后可以看到很详细的安装和启动方法，这里就不展开来讲了。 添加分类1$ hexo new page categories 编辑站点的source/categories/index.md，添加 title: categories date: 2015-10-20 06:49:50 type: &quot;categories&quot; comments: false 添加标签1$ hexo new page tags 编辑站点的source/tags/index.md，添加 title: tags date: 2015-10-20 06:49:50 type: &quot;tags&quot; comments: false","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-07-06T03:19:47.025Z","updated":"2017-07-06T03:19:47.026Z","comments":true,"path":"2017/07/06/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}