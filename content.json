{"meta":{"title":"Spider","subtitle":null,"description":"工作是为了更好的生活","author":"CaoZheng","url":"http://caozhenggit.github.io"},"pages":[{"title":"categories","date":"2017-07-07T08:00:15.000Z","updated":"2017-12-08T12:53:51.458Z","comments":false,"path":"categories/index.html","permalink":"http://caozhenggit.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Git 分支管理","slug":"Git-分支管理","date":"2017-12-08T02:17:42.000Z","updated":"2017-12-08T13:32:44.399Z","comments":true,"path":"2017/12/08/Git-分支管理/","link":"","permalink":"http://caozhenggit.github.io/2017/12/08/Git-分支管理/","excerpt":"","text":"创建本地分支git branch &lt;分支名&gt; 切换分支git checkout &lt;分支名&gt; 推送本地分支关联远程分支 远程分支存在并且已关联本地分支： git push 远程分支存在且本地分支也存在，但未关联：git push -u origin &lt;远程分支名&gt; 远程分支不存在但本地分支存在：git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; 拉取远程分支并创建本地分支git checkout -b &lt;本地分支名&gt; origin/&lt;远程分支名&gt; 重命名分支 git branch -m | -M &lt;旧分支名&gt; &lt;新分支名&gt; 删除本地分支 git branch -d &lt;分支名&gt; 删除远程分支 git branch -d -r &lt;分支名&gt; 查看本地分支 git branch 查看本地与远程分支 git branch -a","categories":[{"name":"Git","slug":"Git","permalink":"http://caozhenggit.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://caozhenggit.github.io/tags/git/"}]},{"title":"【广告篇】仿知乎长图片广告滚动效果","slug":"【广告篇】仿知乎长图片广告滚动效果","date":"2017-11-20T14:33:54.000Z","updated":"2017-12-13T14:45:49.613Z","comments":true,"path":"2017/11/20/【广告篇】仿知乎长图片广告滚动效果/","link":"","permalink":"http://caozhenggit.github.io/2017/11/20/【广告篇】仿知乎长图片广告滚动效果/","excerpt":"","text":"一、概述最近刷知乎的时候看到一个广告，着实被惊艳到了，现在找不到了，大致的样式就是随着列表滚动长图片也跟着滚动。 先看看自己实现的效果图： 思路： 捕获列表滚动的滑动距离，不管是ListView还是RecyclerView都可以 自定义View, 图片显示部分变化随着列表滚动变化，我们可以利用canvas.translate 实现代码： public class ZhiHuAdvertsView extends AppCompatImageView { private RectF mBitmapRectF; private Bitmap mBitmap; private int mHeight; private int mDy; public ZhiHuAdvertsView(Context context){ super(context); } public ZhiHuAdvertsView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } @Override protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) { super.onSizeChanged(width, height, oldWidth, oldHeight); mHeight = height; Drawable drawable = getDrawable(); if (drawable == null) { return; } mBitmap = drawableToBitmap(drawable); mBitmapRectF = new RectF(0, 0, width, mBitmap.getHeight() * width / mBitmap.getWidth()); } private Bitmap drawableToBitmap(Drawable drawable) { if (drawable instanceof BitmapDrawable) { BitmapDrawable bd = (BitmapDrawable) drawable; return bd.getBitmap(); } int width = drawable.getIntrinsicWidth(); int height = drawable.getIntrinsicHeight(); Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, width, height); drawable.draw(canvas); return bitmap; } public void setDy(int dy) { if (getDrawable() == null) { return; } mDy = dy - mHeight; if (mDy &lt;= 0) { mDy = 0; } if (mDy &gt; mBitmapRectF.height() - mHeight) { mDy = (int) (mBitmapRectF.height() - mHeight); } invalidate(); } public void bindView(final ViewGroup parent){ if(parent instanceof RecyclerView){ ((RecyclerView) parent).addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); int[] location = getLocation(); int y = location[1]; //view距离屏幕顶部的高度 + view自身高度 int heightTotal = y + getHeight(); if(getVisibility() == View.VISIBLE){ LinearLayoutManager mLinearLayoutManager = (LinearLayoutManager) ((RecyclerView) parent).getLayoutManager(); //view完全可见时,开始滑动 if (y &gt; 0 &amp;&amp; getScreenHeight() &gt;= heightTotal) { setDy(mLinearLayoutManager.getHeight() - y); } } } }); }else { Log.i(TAG, &quot;不支持的ViewGroup类型&quot;); } } private int getScreenHeight(){ Resources resources = this.getResources(); DisplayMetrics dm = resources.getDisplayMetrics(); return dm.heightPixels; } private int[] getLocation(){ int[] location = new int[2]; //获取view坐标 this.getLocationOnScreen(location); return location; } @Override protected void onDraw(Canvas canvas) { if (mBitmap == null) { return; } canvas.save(); canvas.translate(0, -mDy); canvas.drawBitmap(mBitmap, null, mBitmapRectF, null); canvas.restore(); } 开源大法好源代码地址","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[]},{"title":"【广告篇】仿QQ空间图片广告切换效果","slug":"【广告篇】仿QQ空间图片广告切换效果","date":"2017-11-13T13:37:15.000Z","updated":"2017-12-13T14:45:40.400Z","comments":true,"path":"2017/11/13/【广告篇】仿QQ空间图片广告切换效果/","link":"","permalink":"http://caozhenggit.github.io/2017/11/13/【广告篇】仿QQ空间图片广告切换效果/","excerpt":"","text":"一、概述最近看到很多创意的广告效果，今天挑了一个QQ空间里面的广告切换效果，在将列表中的item显示广告，随着列表的滚动切换图片。 效果图如下： 二、实现思路： 捕获列表滚动的滑动距离，不管是ListView还是RecyclerView都可以 自定义View, 绘制两个bitmap到画布上，通过传入的列表滑动的值确定其中一张图片被遮挡的值，这里需要了解一下Xfermode的PorterDuff.Mode.DST_IN属性，即显示两个图层的交集，底层图层位于顶层图层上面。 实现： 1.初始化画笔 private void init(){ mPaint = new Paint(); mPaint.setAlpha(0); //取两层交集的内容，显示最下层绘制 mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); mPaint.setStyle(Paint.Style.FILL); mPaint.setAntiAlias(true); mPaint.setStrokeWidth(0); mPaint.setStrokeJoin(Paint.Join.ROUND); mPaint.setStrokeCap(Paint.Cap.ROUND); } 2.初始化布局 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); width = MeasureSpec.getSize(widthMeasureSpec); height = MeasureSpec.getSize(heightMeasureSpec); rectF = new RectF(0, 0, width, height); //创建空bitmap frontBg = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); //创建前景画布 frontCanvas = new Canvas(frontBg); } 3.绘制 @Override protected void onDraw(Canvas behindCanvas) { super.onDraw(behindCanvas); //绘制背景图片至背景画布 behindCanvas.drawBitmap(getBitmap(mBehindImage), null, rectF, null); //初始时背景图片不可见，防止遮挡前景画布 behindCanvas.drawBitmap(frontBg, null, rectF, null); //绘制前景图片至前景画布 frontCanvas.drawBitmap(getBitmap(mFrontImage), null, rectF, null); //绘制圆遮挡前景图片 frontCanvas.drawCircle(width - offsetX, height - offsetY, radius, mPaint); } 4.绑定ViewGroup获取列表滚动的距离并不断重新绘制 public void bindView(ViewGroup parent){ if(parent instanceof RecyclerView){ ((RecyclerView) parent).addOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); getLocation(); } }); }else if(parent instanceof ListView){ ((ListView) parent).setOnScrollChangeListener(new OnScrollChangeListener() { @Override public void onScrollChange(View view, int i, int i1, int i2, int i3) { getLocation(); } }); }else { Log.i(TAG, &quot;不支持的ViewGroup类型&quot;); } } private void getLocation() { int[] location = new int[2]; //获取view在屏幕中的坐标 this.getLocationOnScreen(location); int y = location[1]; //view距离屏幕顶部的高度 + view自身高度 int heightTotal = y + getHeight(); //向上滑动, 放大圆的半径 //向下滑动, 缩小圆的半径 if (y &gt; 0 &amp;&amp; getScreenHeight() &gt;= heightTotal) { radius = (float) ((getScreenHeight() - heightTotal) * 1.5); frontCanvas.drawCircle(width - offsetX, heightTotal - offsetY, radius, mPaint); } else { if (radius &lt; width) { radius = 0; } } invalidate(); } 总结： 到这里就已经基本的实现我们想要的View了，大致思路就是搞两块画布，随着滚动不停的在其中一块画布上扩大圆的半径遮挡住画布实现。 开源大法好源代码地址","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[]},{"title":"【Android异常】关于Android方法数量限制的问题","slug":"【Android异常】关于Android方法数量限制的问题","date":"2017-10-11T03:44:58.000Z","updated":"2017-12-08T12:53:51.455Z","comments":true,"path":"2017/10/11/【Android异常】关于Android方法数量限制的问题/","link":"","permalink":"http://caozhenggit.github.io/2017/10/11/【Android异常】关于Android方法数量限制的问题/","excerpt":"","text":"异常错误信息错误信息： 12345Error:Errorconverting bytecode to dex:Cause:com.android.dex.DexIndexOverflowException:field ID not in [0, 0xffff]: 65536:XXXXXX:transformClassesWithDexForDebug FAILEDError:Executionfailed for task ':XXXXXX:transformClassesWithDexForDebug'.&gt;com.android.build.api.transform.TransformException:com.android.ide.common.process.ProcessException:java.util.concurrent.ExecutionException:com.android.ide.common.process.ProcessException:org.gradle.process.internal.ExecException: Process 'command 'C:\\ProgramFiles\\Java\\jdk1.8.0_73\\bin\\java.exe'' finished withnon-zero exit value 2 限制Android方法数量的原因Android应用以DEX文件的形式存储字节码文件，在Dalvik字节码规范里，方法引用索引method referenceindex只有16位,即65536个。注意是method reference，这里限制的是自己代码、Android框架、第三方库三者方法数量的总和。 解决方法Google官方出的分包方案，采用MultiDex支持库 1，配置building.gradle，开启MultiDex 123456789android &#123; defaultConfig &#123; multiDexEnabled true &#125;&#125;dependencies&#123; compile'com.android.support:multidex:1.0.0'&#125;&#125; 2，配置应用 方法1：在AndroidManifest.xml的application中声明android.support.multidex.MultiDexApplication； 123456789&lt;?xmlversion=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifestxmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.android.multidex.myapplication\"&gt; &lt;application ... android:name=\"android.support.multidex.MultiDexApplication\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 方法2：让你自己的Application类继承MultiDexApplication 方法3：让你自己的Application类重写attachBaseContext 方法，12345@Overrideprotected void attachBaseContext(Context base) &#123;super.attachBaseContext(base);MultiDex.install(this);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[{"name":"异常","slug":"异常","permalink":"http://caozhenggit.github.io/tags/异常/"}]},{"title":"【Android开源框架】之数据库框架","slug":"【Android开源框架】之数据库框架","date":"2017-09-27T04:40:27.000Z","updated":"2017-12-08T12:53:51.455Z","comments":true,"path":"2017/09/27/【Android开源框架】之数据库框架/","link":"","permalink":"http://caozhenggit.github.io/2017/09/27/【Android开源框架】之数据库框架/","excerpt":"","text":"GreenDAOGreenDAO是一个轻量级，快速的orm框架。简化建表、查询、更新、插入、事务、索引的操作特性: 性能突出(比ormlite快4-5倍), performance 库小，核心包小于100k 简单易用的API 支持protobuf 自动生成数据库访问代码 Realm移动端的数据库，适用于 Phone、Tablet、Wearable，支持 ORM，线程安全、支持连表及数据库加密，比 SQLite 性能更好。特性: 着重移动端 简单易用的API 支持线程安全，关系数据库和加密 访问快速 跨平台 OrmLiteOrmLite不是Android平台专用的orm框架，它是一个Java orm，OrmLite For Android增加了对Android平台的支持。 ActiveAndroidActiveAndroid是一个轻量级的orm框架，名称命令方式类似于Yii、Rails等使用的orm框架ActiveRecord DBFlow一个速度极快，功能强大，而且非常简单的 Android 数据库 ORM 库 Sugar用超级简单的方法处理Android数据库特性: 配置少 自动生成表结构 支持在不同模式版本直接切换","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://caozhenggit.github.io/tags/数据库/"}]},{"title":"【Android面试题】之Android基础","slug":"【Android面试题】之Android基础","date":"2017-09-27T04:40:27.000Z","updated":"2017-12-08T14:14:29.324Z","comments":true,"path":"2017/09/27/【Android面试题】之Android基础/","link":"","permalink":"http://caozhenggit.github.io/2017/09/27/【Android面试题】之Android基础/","excerpt":"","text":"Android 面试题——Android基础1. Android的四大组件是哪些，它们的作用？Activity：Activity是Android程序与用户交互的窗口，是Android构造块中最基本的一种，它需要为保持各界面的状态，做很多持久化的事情，妥善管理生命周期以及一些跳转逻辑 Service：后台服务于Activity，封装有一个完整的功能逻辑实现，接受上层指令，完成相关的事物，定义好需要接受的Intent提供同步和异步的接口 Content Provider：是Android提供的第三方应用数据的访问方案，可以派生Content Provider类，对外提供数据，可以像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的借口模型，大大简化上层应用，对数据的整合提供了更方便的途径 BroadCast Receiver：接受一种或者多种Intent作触发事件，接受相关消息，做一些简单处理，转换成一条Notification，统一了Android的事件广播模型 2. Android中常用的五种布局常用五种布局方式，分别是：FrameLayout（框架布局），LinearLayout （线性布局），AbsoluteLayout（绝对布局），RelativeLayout（相对布局），TableLayout（表格布局）。 FrameLayout：所有东西依次都放在左上角，会重叠，这个布局比较简单，也只能放一点比较简单的东西。 LinearLayout：线性布局，每一个LinearLayout里面又可分为垂直布局（android:orientation=”vertical”）和水平布局（android:orientation=”horizontal” ）。当垂直布局时，每一行就只有一个元素，多个元素依次垂直往下；水平布局时，只有一行，每一个元素依次向右排列。 AbsoluteLayout：绝对布局用X,Y坐标来指定元素的位置，这种布局方式也比较简单，但是在屏幕旋转时，往往会出问题，而且多个元素的时候，计算比较麻烦。 RelativeLayout：相对布局可以理解为某一个元素为参照物，来定位的布局方式。主要属性有：相对于某一个元素android:layout_below、 android:layout_toLeftOf相对于父元素的地方android:layout_alignParentLeft、android:layout_alignParentRigh； TableLayout：表格布局，每一个TableLayout里面有表格行TableRow，TableRow里面可以具体定义每一个元素。每一个布局都有自己适合的方式，这五个布局元素可以相互嵌套应用，做出美观的界面。 3. android中的动画有哪几类，它们的特点和区别两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化;另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。 4. ListView的优化方案 如果自定义适配器，那么在getView方法中要考虑方法传进来的参数contentView是否为null，如果为null就创建contentView并返回，如果不为null则直接使用。在这个方法中尽可能少创建view。 给contentView设置tag（setTag（）），传入一个viewHolder对象，用于缓存要显示的数据，可以达到图像数据异步加载的效果。 如果listview需要显示的item很多，就要考虑分页加载。比如一共要显示100条或者更多的时候，我们可以考虑先加载20条，等用户拉到列表底部的时候再去加载接下来的20条。 5. Android的数据存储方式SharedPreferences存储数据；文件存储数据；SQLite数据库存储数据；使用ContentProvider存储数据；网络存储数据； 6. 跟activity和Task 有关的 Intent启动方式有哪些？其含义？ FLAG_ACTIVITY_NEW_TASK:这个Activity会成为历史stack中一个新Task的开始。一个Task（从启动它的Activity到下一个Task中的 Activity）定义了用户可以迁移的Activity原子组。Task可以移动到前台和后台；在某个特定Task中的所有Activity总是保持相同的次序。这个标志一般用于呈现“启动”类型的行为：它们提供用户一系列可以单独完成的事情，与启动它们的Activity完全无关。使用这个标志，如果正在启动的Activity的Task已经在运行的话，那么，新的Activity将不会启动；代替的，当前Task会简单的移入前台。 FLAG_ACTIVITY_CLEAR_TOP:并且这个Activity已经在当前的Task中运行，因此，不再是重新启动一个这个Activity的实例，而是在这个Activity上方的所有Activity都将关闭，然后这个Intent会作为一个新的Intent投递到老的Activity（现在位于顶端）中。 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED:如果设置这个标志，这个activity不管是从一个新的栈启动还是从已有栈推到栈顶，它都将以the front door of the task的方式启动。这就讲导致任何与应用相关的栈都讲重置到正常状态（不管是正在讲activity移入还是移除），如果需要，或者直接重置该栈为初始状态。 FLAG_ACTIVITY_SINGLE_TOP:如果设置，当这个Activity位于历史stack的顶端运行时，不再启动一个新的 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET:如果设置，这将在Task的Activity stack中设置一个还原点，当Task恢复时，需要清理Activity。也就是说，下一次Task带着 7. Activity的生命周期 8. Activity在屏幕旋转时的生命周期不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次；设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次；设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 9. 单线程模型中Message、Handler、Message Queue、Looper之间的关系Handler获取当前线程中的looper对象，looper用来从存放Message的MessageQueue中取出Message，再有Handler进行Message的分发和处理. Message Queue(消息队列)：用来存放通过Handler发布的消息，通常附属于某一个创建它的线程，可以通过Looper.myQueue()得到当前线程的消息队列 Handler：可以发布或者处理一个消息或者操作一个Runnable，通过Handler发布消息，消息将只会发送到与它关联的消息队列，然也只能处理该消息队列中的消息 Looper：是Handler和消息队列之间通讯桥梁，程序组件首先通过Handler把消息传递给Looper，Looper把消息放入队列。Looper也把消息队列里的消息广播给所有的 Handler：Handler接受到消息后调用handleMessage进行处理 Message：消息的类型，在Handler类中的handleMessage方法中得到单个的消息进行处理 10. MVC模式的原理 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 11. MVP模式的原理 MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 12. MVVP模式的原理 MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然 13. 什么是ANR？ 如何避免它？ANR：Application Not Responding。在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作的在5s内应用程序没能做出反应，BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，这既是ANR。 避免方法：Activity应该在它的关键生命周期方法（如onCreate()和onResume()）里尽可能少的去做创建操作。潜在的耗时操作，例如网络或数据库操作，或者高耗时的计算如改变位图尺寸，应该在子线程里（或者异步方式）来完成。主线程应该为子线程提供一个Handler，以便完成时能够提交给主线程。 14. Android的系统架构android系统架构分从下往上为linux 内核层、运行库、应用程序框架层、和应用程序层。 linux kernel：负责硬件的驱动程序、网络、电源、系统安全以及内存管理等功能。 libraries和 android runtime：libraries：即c/c++函数库部分，大多数都是开放源代码的函数库，例如webkit（引擎），该函数库负责 android网页浏览器的运行，例如标准的c函数库libc、openssl、sqlite等，当然也包括支持游戏开发2dsgl和 3dopengles，在多媒体方面有mediaframework框架来支持各种影音和图形文件的播放与显示，例如mpeg4、h.264、mp3、 aac、amr、jpg和png等众多的多媒体文件格式。android的runtime负责解释和执行生成的dalvik格式的字节码。 applicationframework（应用软件架构），java应用程序开发人员主要是使用该层封装好的api进行快速开发。 applications:该层是java的应用程序层，android内置的googlemaps、e-mail、即时通信工具、浏览器、mp3播放器等处于该层，java开发人员开发的程序也处于该层，而且和内置的应用程序具有平等的位置，可以调用内置的应用程序，也可以替换内置的应用程序。 上面的四个层次，下层为上层服务，上层需要下层的支持，调用下层的服务，这种严格分层的方式带来的极大的稳定性、灵活性和可扩展性，使得不同层的开发人员可以按照规范专心特定层的开发。 android应用程序使用框架的api并在框架下运行，这就带来了程序开发的高度一致性，另一方面也告诉我们，要想写出优质高效的程序就必须对整个 applicationframework进行非常深入的理解。精通applicationframework，你就可以真正的理解android的设计和运行机制，也就更能够驾驭整个应用层的开发。 15. 如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态？重写onSaveInstanceState()方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写onRestoreInstanceState()方法可以从中提取保存好的数据 16. 如何将SQLite数据库(dictionary.db文件)与apk文件一起发布可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中 17. 如何将打开res aw目录中的数据库文件?在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。 复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。 18. 谈谈Android的IPC（进程间通信）机制IPC是内部进程通信的简称， 是共享”命名管道”的资源。Android中的IPC机制是为了让Activity和Service之间可以随时的进行交互，故在Android中该机制，只适用于Activity和Service之间的通信，类似于远程方法调用，类似于C/S模式的访问。通过定义AIDL接口文件来定义IPC接口。Servier端实现IPC接口，Client端调用IPC接口本地代理。 19. NDK是什么NDK是一些列工具的集合，NDK提供了一系列的工具，帮助开发者迅速的开发C/C++的动态库，并能自动将so和java 应用打成apk包。 NDK集成了交叉编译器，并提供了相应的mk文件和隔离cpu、平台等的差异，开发人员只需简单的修改mk文件就可以创建出so","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://caozhenggit.github.io/tags/面试题/"}]},{"title":"Android开发中定制自己的线程池","slug":"Android开发中定制自己的线程池","date":"2017-08-27T09:05:04.000Z","updated":"2017-12-13T14:45:18.004Z","comments":true,"path":"2017/08/27/Android开发中定制自己的线程池/","link":"","permalink":"http://caozhenggit.github.io/2017/08/27/Android开发中定制自己的线程池/","excerpt":"","text":"线程池算是Android开发中非常常用的一个东西了，只要涉及到线程的地方，大多数情况下都会涉及到线程池。Android开发中线程池的使用和Java中线程池的使用基本一致。那么今天我想来总结一下Android开发中线程池的使用。 ThreadPoolExecutor的构造方法ThreadPoolExecutor的构造方法有四个，如下: 12345678910111213141516171819202122232425262728293031323334353637public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造方法参数说明 corePoolSize 线程池的核心线程数，即线程池中的最小线程数 maximumPoolSize 最大线程池大小,当活动线程数达到这个值，后续任务会被阻塞 keepAliveTime 线程池中超过corePoolSize数目的非核心线程最大存活时间 unit keepAliveTime 参数的时间单位 workQueue 执行前用于保持任务的队列，也就是线程池的缓存队列 threadFactory 线程工厂，为线程池提供创建新线程的功能 RejectedExecutionHandler 线程池对拒绝任务的处理策略 定制自己的线程池1234567891011121314151617181920212223242526272829303132333435363738public class ThreadPoolFactory &#123; /** 核心线程数 */ private static final int CORE_POOL_SIZE = 5; /** 最大线程数 */ private static final int MAX_POOL_SIZE = 128; /** 非核心线程时超过时长 */ private static final int KEEP_ALIVE_TIME = 2; /** 阻塞队列大小 */ private static final int BLOCK_SIZE = 2; private ThreadPoolExecutor mThreadPoolExecutor ; private ThreadPoolFactory()&#123; createThreadPoolProxyFactory(); &#125; /** 创建线程池 */ private void createThreadPoolProxyFactory()&#123; mThreadPoolExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(BLOCK_SIZE), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); //true: 线程池数量最后销毁到0个 //false: 超过核心线程数时,而且(超过最大值或者timeout过),就会销毁 mThreadPoolExecutor .allowCoreThreadTimeOut(true); &#125; /** * 打印线程池状态 */ public void logThreadPoolInfo() &#123; Log.i(\"threadPoolFactory\", \"monitor \" + \" CorePoolSize:\" + mThreadPoolExecutor.getCorePoolSize() + \" PoolSize:\" + mThreadPoolExecutor.getPoolSize() + \" MaximumPoolSize:\" + mThreadPoolExecutor.getMaximumPoolSize() + \" ActiveCount:\" + mThreadPoolExecutor.getActiveCount() + \" TaskCount:\" + mThreadPoolExecutor.getTaskCount()); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://caozhenggit.github.io/tags/线程/"}]},{"title":"Java线程池的使用","slug":"Java线程池的使用","date":"2017-08-27T03:30:18.000Z","updated":"2017-12-13T14:45:31.059Z","comments":true,"path":"2017/08/27/Java线程池的使用/","link":"","permalink":"http://caozhenggit.github.io/2017/08/27/Java线程池的使用/","excerpt":"","text":"new Thread与线程池new Thread的弊端 每次new Thread新建对象性能差。 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。 缺乏更多功能，如定时执行、定期执行、线程中断。 相比new Thread，Java提供的四种线程池的好处在于： 重用存在的线程，减少对象创建、消亡的开销，性能佳。 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 提供定时执行、定期执行、单线程、并发数控制等功能。 四种线程池newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 12ExecutorService cacheThreadPool = Executors.newCachedThreadPool(); cacheThreadPool.execute(runnable); newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 12ExecutorService fixedThreadPool = Executors.newFixedThreadPool(4); fixedThreadPool.execute(runnable); newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 12ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4); scheduledThreadPool.schedule(runnable3, 2000, TimeUnit.MILLISECONDS); newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 12ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();singleThreadExecutor.execute(runnable);","categories":[{"name":"Java","slug":"Java","permalink":"http://caozhenggit.github.io/categories/Java/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://caozhenggit.github.io/tags/线程/"}]},{"title":"Hexo常用命令笔记","slug":"Hexo常用命令笔记","date":"2017-07-31T02:44:40.000Z","updated":"2017-12-08T12:53:51.452Z","comments":true,"path":"2017/07/31/Hexo常用命令笔记/","link":"","permalink":"http://caozhenggit.github.io/2017/07/31/Hexo常用命令笔记/","excerpt":"","text":"hexo npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写 hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deploy hexo deploy –generate hexo deploy -g hexo server -g 草稿 hexo publish [layout] 模版 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] hexo new photo “My Gallery” hexo new “Hello World” –lang tw 变量 描述layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://caozhenggit.github.io/categories/Hexo/"}],"tags":[]},{"title":"Git 配置用户名、密码","slug":"Git-配置用户名、密码","date":"2017-07-31T02:40:10.000Z","updated":"2017-12-08T12:53:51.450Z","comments":true,"path":"2017/07/31/Git-配置用户名、密码/","link":"","permalink":"http://caozhenggit.github.io/2017/07/31/Git-配置用户名、密码/","excerpt":"","text":"在终端输入： 1$ git config --global credential.helper store 然后git pull一次，输入一次用户名密码就会自动保存该用户名密码； 查看配置的用户信息： 1$ git config --list","categories":[{"name":"Git","slug":"Git","permalink":"http://caozhenggit.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://caozhenggit.github.io/tags/git/"}]},{"title":"Markdown 基本语法","slug":"Markdown-基本语法","date":"2017-07-12T02:51:11.000Z","updated":"2017-12-08T12:53:51.453Z","comments":true,"path":"2017/07/12/Markdown-基本语法/","link":"","permalink":"http://caozhenggit.github.io/2017/07/12/Markdown-基本语法/","excerpt":"","text":"关于MarkdownMarkdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 简单标记符完成排版，所写即所见，让你专注于文字而不是排版 纯文本，所以兼容性极强，可以用所有文本编辑器打开 格式转换方便，Markdown文本可以轻松转换为 html、pdf等 Markdown 的标记语法有极好的可读性 基础语法基础语法 高级语法高级语法","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://caozhenggit.github.io/categories/Markdown/"}],"tags":[]},{"title":" 开源弹幕引擎·烈焰弹幕使(DanmakuFlameMaster)","slug":"开源弹幕引擎·烈焰弹幕使-DanmakuFlameMaster","date":"2017-07-11T05:35:13.000Z","updated":"2017-12-08T12:53:51.457Z","comments":true,"path":"2017/07/11/开源弹幕引擎·烈焰弹幕使-DanmakuFlameMaster/","link":"","permalink":"http://caozhenggit.github.io/2017/07/11/开源弹幕引擎·烈焰弹幕使-DanmakuFlameMaster/","excerpt":"","text":"简介DanmakuFlameMaster 是 Android 上开源弹幕解析绘制引擎项目，也是 Android 上最好的开源弹幕引擎·烈焰弹幕。其架构清晰，简单易用，支持多种高效绘制 B站xml弹幕格式解析 基础弹幕精确还原绘制 支持mode7特殊弹幕 多核机型优化，高效的预缓存机制 支持多种显示效果选项实时切换 实时弹幕显示支持 换行弹幕支持/运动弹幕支持 支持自定义字体 支持多种弹幕参数设置 支持多种方式的弹幕屏蔽 项目地址github地址：https://github.com/Bilibili/DanmakuFlameMaster Android Studio集成方法build.gradle中添加 123dependencies &#123; compile 'com.github.ctiao:dfm:0.4.2'&#125; 使用方法1.布局文件 1234&lt;master.flame.danmaku.ui.widget.DanmakuView android:id=\"@+id/sv_danmaku\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 2.初始化 private BaseDanmakuParser mParser;//解析器对象 private IDanmakuView mDanmakuView; private DanmakuContext mContext; mDanmakuView = (IDanmakuView) findViewById(R.id.sv_danmaku); mContext = DanmakuContext.create(); // 设置弹幕的最大显示行数 HashMap&lt;Integer, Integer&gt; maxLinesPair = new HashMap&lt;Integer, Integer&gt;(); // 滚动弹幕最大显示3行 maxLinesPair.put(BaseDanmaku.TYPE_SCROLL_RL, 3); // 设置是否禁止重叠 HashMap&lt;Integer, Boolean&gt; overlappingEnablePair = new HashMap&lt;Integer, Boolean&gt;(); overlappingEnablePair.put(BaseDanmaku.TYPE_SCROLL_LR, true); overlappingEnablePair.put(BaseDanmaku.TYPE_FIX_BOTTOM, true); mContext.setDanmakuStyle(IDisplayer.DANMAKU_STYLE_STROKEN, 3) .setDuplicateMergingEnabled(false) .setScrollSpeedFactor(1.2f) //是否启用合并重复弹幕 .setScaleTextSize(1.2f) //设置弹幕滚动速度系数,只对滚动弹幕有效 .setCacheStuffer(new SpannedCacheStuffer(), mCacheStufferAdapter) // 图文混排使用SpannedCacheStuffer 设置缓存绘制填充器，默认使用{@link SimpleTextCacheStuffer}只支持纯文字显示, 如果需要图文混排请设置{@link SpannedCacheStuffer}如果需要定制其他样式请扩展{@link SimpleTextCacheStuffer}|{@link SpannedCacheStuffer} .setMaximumLines(maxLinesPair) //设置最大显示行数 .preventOverlapping(overlappingEnablePair); //设置防弹幕重叠，null为允许重叠 if (mDanmakuView != null) { mParser = createParser(this.getResources().openRawResource(R.raw.comments)); //创建解析器对象，从raw资源目录下解析comments.xml文本 mDanmakuView.setCallback(new master.flame.danmaku.controller.DrawHandler.Callback() { @Override public void updateTimer(DanmakuTimer timer) { } @Override public void drawingFinished() { } @Override public void danmakuShown(BaseDanmaku danmaku) { } @Override public void prepared() { mDanmakuView.start(); } }); mDanmakuView.prepare(mParser, mContext); mDanmakuView.showFPS(false); //是否显示FPS mDanmakuView.enableDanmakuDrawingCache(true); 3.创建解析器对象 /** * 创建解析器对象，解析输入流 * @param stream * @return */ private BaseDanmakuParser createParser(InputStream stream) { if (stream == null) { return new BaseDanmakuParser() { @Override protected Danmakus parse() { return new Danmakus(); } }; } ILoader loader = DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI); try { loader.load(stream); } catch (IllegalDataException e) { e.printStackTrace(); } BaseDanmakuParser parser = new BiliDanmukuParser(); IDataSource&lt;?&gt; dataSource = loader.getDataSource(); parser.load(dataSource); return parser; } 注： DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_BILI) //xml解析 DanmakuLoaderFactory.create(DanmakuLoaderFactory.TAG_ACFUN) //json文件格式解析 4.自定义弹幕背景和边距 private static class BackgroundCacheStuffer extends SpannedCacheStuffer { // 通过扩展SimpleTextCacheStuffer或SpannedCacheStuffer个性化你的弹幕样式 final Paint paint = new Paint(); @Override public void measure(BaseDanmaku danmaku, TextPaint paint) { danmaku.padding = 10; // 在背景绘制模式下增加padding super.measure(danmaku, paint); } @Override public void drawBackground(BaseDanmaku danmaku, Canvas canvas, float left, float top) { paint.setColor(0x8125309b); //弹幕背景颜色 canvas.drawRect(left + 2, top + 2, left + danmaku.paintWidth - 2, top + danmaku.paintHeight - 2, paint); } @Override public void drawStroke(BaseDanmaku danmaku, String lineText, Canvas canvas, float left, float top, Paint paint) { // 禁用描边绘制 } }","categories":[{"name":"Android","slug":"Android","permalink":"http://caozhenggit.github.io/categories/Android/"}],"tags":[]},{"title":"毕业后这一年的收获","slug":"毕业后这一年的收获","date":"2017-07-07T07:00:11.000Z","updated":"2017-12-08T12:53:51.457Z","comments":true,"path":"2017/07/07/毕业后这一年的收获/","link":"","permalink":"http://caozhenggit.github.io/2017/07/07/毕业后这一年的收获/","excerpt":"","text":"去年的七月拿到毕业证正式毕业，一转眼就又是七月了，这一年还是经历了不少事，回头看看，这一年中的大多数选择还是比较满意的。今天趁着懒癌没发作，总结一下这一年的收获吧。 当前状况毕业一年，上海，创业公司，安卓开发，无房无车，几乎无存款，身体还算健康，但缺乏锻炼免疫力差，离家很远。 工作方面毕业后与毕业前最大的改变就是进入社会，开始工作。 庆幸今年没有因为工作中的一点不顺心就离职，毕竟工作还不满一年，那会儿换工作的话还需要花时间适应新工作新环境，能够用来学习提升的时间就更少了。 人们常说第一份工作会影响人的很多方面，包括人生观、价值观，的确如此，在过去一年工作中，我所在的公司在不停地变化，处在这个环境中的我，受益很多。 目标业务代码沟通协作未来目标在开始工作之前，我并没有思考过我为什么工作，因此在过去一年里我浪费了很多时间纠结迷茫徘徊，如果连目标都没设定，怎么能走得直走得快呢？ 工作的目的有很多，除了钱是一部分原因，有的人是不知道该干什么就先工作着吧，有的人是为了学技能攒经验去做更好的事，有的人是为了做些事业实现梦想，也有的人只是无聊找点事做。 我的中期目标是多年后回老家自己开家信息技术公司，具体业务还不清楚，但是前几年需要比较广地掌握三端（APP、WEB、后台）技能。 因此头两年的小目标就是先夯实安卓开发。 不足总结","categories":[{"name":"生活","slug":"生活","permalink":"http://caozhenggit.github.io/categories/生活/"}],"tags":[]},{"title":"Hexo安装","slug":"Hexo安装","date":"2017-07-07T02:25:12.000Z","updated":"2017-12-08T12:53:51.451Z","comments":true,"path":"2017/07/07/Hexo安装/","link":"","permalink":"http://caozhenggit.github.io/2017/07/07/Hexo安装/","excerpt":"","text":"安装Git我们很经常会要用到Git以及Github，首先来安装Git： 下载Git 选择合适的版本下载然后安装，我们稍后将会用上。 安装Node.js因为Hexo是一款基于Node.js的静态博客框架，所以我们还需要安装好它： 下载Node.js 同样选择对应自己电脑的版本下载安装。 安装Hexo安装好Git和Node.js之后，轮到我们今天的主角登场了~先打开Git Bash，然后输入下面这条命令来安装Hexo： 1$ npm install hexo-cli -g 来试试安装成功没有，输入以下命令查看Hexo的版本信息： 1$ hexo -v 如果出现类似内容说明安装成功啦！ hexo-cli: 0.1.9 os: Windows_NT 6.1.7601 win32 ia32 http_parser: 2.3 node: 0.12.2 v8: 3.28.73 uv: 1.4.2-node1 zlib: 1.2.8 modules: 14 openssl: 1.0.1m Hexo的使用现在我们可以开始创建博客写文章了！是不是很快~下面会介绍几个Hexo的常用命令，掌握之后就能愉悦地开始写作之旅了XD 新建博客假设我在E盘有个叫blog的文件夹，现在我们用Git Bash进去这个文件夹里，然后将它初始化为我们的博客目录： 1$ hexo init 安装成功的提示信息： INFO Copying data to E:\\blog INFO You are almost done! Don&apos;t forget to run &apos;npm install&apos; before you start blogging with Hexo! 注意看到第二条！提示我们在开始使用前要先执行 1$ npm install 这条命令是用来安装依赖包的，具体安装内容可以在package.json文件里找到。安装好了之后会看到一大串的信息，这里就不贴出来了。现在我们可以看到blog目录下的文件结构是这样的： . ├── _config.yml ├── node_modules ├── package.json ├── scaffolds ├── source | └── _posts └── themes 新建文章1$ hexo new \"我的第一篇文章\" 生成界面1$ hexo generate 或者 hexo g 界面预览1$ hexo server 或者 hexo s 我们会看到这样一条提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 打开浏览器访问http://localhost:4000/ 配置信息是不是很激动！成功了有木有~不过等等，博客名写着Hexo，可不是我想的那样噢，还有还有，页面底部的版权信息里作者名字也不是我啊喂！来，我们来改掉它们！ 找到博客根目录下的配置文件_config.yml，用自己喜欢的文本编辑器编辑它。看到# Site的那一部分，里面的title就是博客的名字，subtitle就是副标题，author对应的那个就是作者名字啦，把自己的大名写上去吧！ 还有很多配置项可以修改，这里就不详细讲了，可以查看Hexo官方文档对照着修改配置。 更换主题在这个看脸的世界，我们的博客怎么可以没有颜值呢，折腾完上面的那些之后，是时候给博客挑上件漂亮的“衣服”了。 Hexo官方网站上展示了多套主题，可以按自己的口味挑选，或者动手能力强的，可以试着自己写一套独一无二的主题噢XD 这里以Apollo这个主题为例，进去github页面之后可以看到很详细的安装和启动方法，这里就不展开来讲了。 添加分类1$ hexo new page categories 编辑站点的source/categories/index.md，添加 title: categories date: 2015-10-20 06:49:50 type: &quot;categories&quot; comments: false 添加标签1$ hexo new page tags 编辑站点的source/tags/index.md，添加 title: tags date: 2015-10-20 06:49:50 type: &quot;tags&quot; comments: false","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://caozhenggit.github.io/categories/Hexo/"}],"tags":[]},{"title":"【旅行计划】西藏自驾游","slug":"【旅行计划】西藏自驾游","date":"2017-05-01T06:54:41.000Z","updated":"2017-12-13T14:44:56.339Z","comments":true,"path":"2017/05/01/【旅行计划】西藏自驾游/","link":"","permalink":"http://caozhenggit.github.io/2017/05/01/【旅行计划】西藏自驾游/","excerpt":"","text":"大致路线川藏线 + 青藏线 详细计划Day 1路线：重庆－泸定（1337）－新都桥（3469）－雅江（2600） 里程：760km，路况好 Day 2路线：雅江－理塘（3950）－芒康（3883）里程：400km，路况一般，弯多灰大 Day 3路线：芒康—左贡（3807）—八宿（3268） 里程：360km，路况一般，有涉水路段 景点：怒江七十二拐、川藏318经典垭口 Day 4路线：八宿—然乌湖（3900）—米堆冰川（3820）—波密（2724） 里程：220km，路况一般，有涉水路段，有落石路段 行程亮点：然乌湖、米堆冰川、波密景观大道 Day 5路线：波密—鲁朗（3383）—林芝 里程：230km，路况一般 行程亮点：通麦天险、鲁朗林海、南迦巴瓦峰 Day 6路线：林芝（3150）—工布江达（3419）—墨竹工卡（3820）—拉萨（3658） 里程：400km，路况好 行程亮点：拉林高速、尼洋河风光、米拉山 Day 7路线：拉萨—羊卓雍措（4440）—拉萨 里程：200km，路况好 行程亮点：羊卓雍措、雅鲁藏布江风光 Day 8路线：拉萨—当雄（4300）—纳木措（4718） 里程：220km，路况好 行程亮点：纳木措、星空 Day 9路线：纳木措—那曲（4500）－安多（4700） 里程：360km，路况好 行程亮点：纳木措日出、青藏铁路 Day 10路线：安多—唐古拉山（4900）－可可西里（4000）－格尔木（2900） 里程：700km（12小时），路况好 行程亮点：唐古拉山垭口、沱沱河、可可西里 Day 11路线：格尔木－茶卡盐湖（3100）－青海湖（3000） 里程：620km（7小时），路况好 行程亮点：茶卡盐湖、青海湖 Day 12路线：青海湖－天水 - 重庆 里程：1500km，路况好 费用油费：4000元 停车费：500元 食宿（2人）：吃150元/日，住200元/日，总计350元 景区门票：海螺沟景区：门票80元/人，观光车票60元/人（双程），观光索道150元/人（双程）； 亚丁风景区：门票150元/人，观光车120元/人，电瓶观光车80元，景区马费80—300元/人； 米堆冰川：50元/人；来古冰川：30/人；雅鲁藏布江大峡谷290元/人 布达拉宫：旺季200元/人，淡季100元/人；大昭寺：85元/人 哲蚌寺：55元/人；色拉寺：55元/人 小昭寺：20元/人；药王山：20元/人 甘丹寺：45元/人；纳木错：淡季100元/人，旺季120元/人 楚布寺：45元/人；直贡梯寺：45元/人 车辆保养和维修：大约在1000—3000元左右 注意事项 在藏区加油一定需要出示三个证件：身份证、驾驶证、行驶证 住酒店需要登记2人的身份证 过检查站时，除了司机是在车上检查，因为司机需要将车辆开过去，其余每个人都要下车到检查站里刷身份证才能通行，而且车上的行李都需要在旁边过安检，所以不要带违禁物品 除了正式的检查站之外，路上也有一些临时检查点，他们一般会在车上抽查一到二个人，然后检查身份证 高原地区的气候特点是早晚温差比较大 随车装备可准备充分一些，吃的喝的，自带了电热水壶和矿泉水 高原地区非常干燥，因此要多带一些保湿性比较好的护肤品，补水面膜也可以带着 高反药品：氧气包肯定必备，一旦高反吸氧是最好的治疗方法，其他高反药品 随车的工具箱、备胎、充气泵、搭电装备、拉车绳都需要带上","categories":[{"name":"旅行计划","slug":"旅行计划","permalink":"http://caozhenggit.github.io/categories/旅行计划/"}],"tags":[]}]}