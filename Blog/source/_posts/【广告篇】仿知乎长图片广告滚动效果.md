---
title: 【广告篇】仿知乎长图片广告滚动效果
date: 2017-11-20 22:33:54
categories: "Android"
---

#### 一、概述 ####
最近刷知乎的时候看到一个广告，着实被惊艳到了，现在找不到了，大致的样式就是随着列表滚动长图片也跟着滚动。

先看看自己实现的效果图：

![](https://camo.githubusercontent.com/08f533e6e4df9d475c0597017be68d26bad1ee44/68747470733a2f2f692e696d6775722e636f6d2f684a58773167752e676966)

**思路：**


1. 捕获列表滚动的滑动距离，不管是ListView还是RecyclerView都可以
2. 自定义View, 图片显示部分变化随着列表滚动变化，我们可以利用canvas.translate

**实现代码：**

	public class ZhiHuAdvertsView extends AppCompatImageView {

    private RectF mBitmapRectF;
    private Bitmap mBitmap;

    private int mHeight;
    private int mDy;

    public ZhiHuAdvertsView(Context context){
        super(context);
    }

    public ZhiHuAdvertsView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
        super.onSizeChanged(width, height, oldWidth, oldHeight);

        mHeight = height;
        Drawable drawable = getDrawable();

        if (drawable == null) {
            return;
        }

        mBitmap = drawableToBitmap(drawable);
        mBitmapRectF = new RectF(0, 0, width,
                mBitmap.getHeight() * width / mBitmap.getWidth());

    }

    private Bitmap drawableToBitmap(Drawable drawable) {
        if (drawable instanceof BitmapDrawable) {
            BitmapDrawable bd = (BitmapDrawable) drawable;
            return bd.getBitmap();
        }
        int width = drawable.getIntrinsicWidth();
        int height = drawable.getIntrinsicHeight();
        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        drawable.setBounds(0, 0, width, height);
        drawable.draw(canvas);
        return bitmap;
    }

    public void setDy(int dy) {
        if (getDrawable() == null) {
            return;
        }

        mDy = dy - mHeight;
        if (mDy <= 0) {
            mDy = 0;
        }

        if (mDy > mBitmapRectF.height() - mHeight) {
            mDy = (int) (mBitmapRectF.height() - mHeight);
        }

        invalidate();
    }

    public void bindView(final ViewGroup parent){
        if(parent instanceof RecyclerView){
            ((RecyclerView) parent).addOnScrollListener(new RecyclerView.OnScrollListener() {
                @Override
                public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
                    super.onScrolled(recyclerView, dx, dy);

                    int[] location = getLocation();
                    int y = location[1];
                    //view距离屏幕顶部的高度 + view自身高度
                    int heightTotal = y + getHeight();

                    if(getVisibility() == View.VISIBLE){
                        LinearLayoutManager mLinearLayoutManager = (LinearLayoutManager) ((RecyclerView) parent).getLayoutManager();

                        //view完全可见时,开始滑动
                        if (y > 0 && getScreenHeight() >= heightTotal) {
                            setDy(mLinearLayoutManager.getHeight() - y);
                        }
                    }
                }
            });
        }else {
            Log.i(TAG, "不支持的ViewGroup类型");
        }
    }

    private int getScreenHeight(){
        Resources resources = this.getResources();
        DisplayMetrics dm = resources.getDisplayMetrics();

        return dm.heightPixels;
    }

    private int[] getLocation(){
        int[] location = new int[2];
        //获取view坐标
        this.getLocationOnScreen(location);

        return location;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (mBitmap == null) {
            return;
        }
        canvas.save();
        canvas.translate(0, -mDy);
        canvas.drawBitmap(mBitmap, null, mBitmapRectF, null);
        canvas.restore();
    }



#### 开源大法好 ####

[源代码地址](https://github.com/caozhenggit/Advertise)